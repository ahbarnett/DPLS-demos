function [u, u_nat] = StokesScloseeval(x, s, sigma, side)
% STOKESSCLOSEEVAL - evaluate Stokes SLP potential due to smooth closed curve
%
% u = StokesSevalclose(x,s,tau,side) returns potentials at targets x due to
%  single-layer potential with density sigma living on curve s.
%  The SLP is broken down into 3 Laplace SLP potential calls,
%  each of which are evaluated with the globally-compensated scheme.
%  "side" controls whether targets are inside (default) or outside.
%  (A mixture isn't allowed).
%
% [u n_nat] = StokesSevalclose(x,s,tau,side) also outputs the native (standard
%  trapezoid rule) potential evalation.
%
% Inputs:
% x = M-by-1 list of targets in complex plane 
% s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     s.a one interior point far from bdry (mean(s.x) used if not provided).
% sigma = single-layer density values (N-by-1) at nodes, in complex notation:
%     real, imag contains the 1,2 vector components.
% side = 'i','e' (default) to indicate targets are all interior or exterior
%     to the curve.
%
% Outputs:
% u = velocity values at targets x (M-by-1): real, imag contains 1,2 components
%
% needs: lapSevalclose.m
%
% Also see: QUADR, testStokesSDevalclose.m
%
% (c) Bowei Wu, Sept 2014. Tweaks by Barnett 10/8/14

if nargin<4, side = 'e'; end   % default
% sigmac = sigma(1:end/2)+1i*sigma(end/2+1:end);

% find I_1
tau = real(sigma);
[I1x1, I3x1, I3x2] = lapSevalclose(x, s, tau, side);
tau = imag(sigma);
[I1x2, I4x1, I4x2] = lapSevalclose(x, s, tau, side);
I1 = (I1x1+1i*I1x2)/2;

% find I_2
tau = real(s.x.*conj(sigma));
[~, I2x1, I2x2] = lapSevalclose(x, s, tau, side);
I2 = (I2x1+1i*I2x2)/2;

% find I_3
I3 = real(x).*(I3x1(:)+1i*I3x2(:))/2;

% find I_4
I4 = imag(x).*(I4x1(:)+1i*I4x2(:))/2;

% Stokes SLP
u = I1(:)+I2(:)-I3(:)-I4(:);

if nargout>1
    % 'u_nat' is the native evaluation of SLP
    t.x = x;
    sigma = [real(sigma);imag(sigma)];
    ug_temp = SLPmatrix(t,s)*sigma;  % native eval u
    u_nat = ug_temp(1:end/2) + 1i * ug_temp(end/2+1:end);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% end main %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% for u_nat testing only:

function A = SLPmatrix(t,s) % double-layer kernel matrix & targ n-deriv
% t = target seg (x,nx cols), s = src seg, a = optional translation of src seg
% No jump included on self-interaction.
N = numel(s.x); M = numel(t.x);
d = repmat(t.x, [1 N]) - repmat(s.x.', [M 1]);    % C-# displacements mat
r = abs(d);    % dist matrix R^{MxN}

log_part = kron(eye(2),-log(r).*repmat(s.w(:)', [M 1]));

d1 = real(d)./r;
d2 = imag(d)./r;

cross_part = [d1.^2, d1.*d2; d1.*d2, d2.^2].*repmat(s.w(:)', [2*M 2]);

A = (log_part + cross_part)/4/pi;
